# PROJECT_CREATE — Contract Risk Sentinel (Foundry Agents + MCP on AKS + RabbitMQ + Grafana)

This project implements an **always-on contract risk monitoring platform** where:
- **Agents run in Microsoft Foundry** (LangChain/LangGraph)
- **Tool-calling uses MCP** (FastMCP tool servers deployed on AKS)
- **Long-running risk computations run on AKS** (workers)
- **RabbitMQ runs in-cluster** (job/result queues)
- **Grafana/Prometheus/OTel** provide an always-on “risk ops center”

---

## 1) Business Use Case

Continuously monitor a portfolio of contracts for **FX + Interest Rate risk** and generate:
- risk metrics (FX VaR, IR DV01, stress results)
- threshold breach alerts
- audit-ready narratives and hedge recommendations (generated by Foundry agents)

**Why this is “AKS-native”:**
- queue-driven long-running workers
- autoscaling based on queue depth (KEDA)
- observability & SLOs
- reliable job processing (retries / DLQ)

---

## 2) High-level Architecture

**AKS (Orchestration & Compute Plane)**
- `agent-orchestrator`: Event-driven agent invocation service
  - Detects events (RabbitMQ messages, market shocks, threshold breaches)
  - Runs cron-based portfolio scans
  - Invokes Foundry agents via API
  - Provides controlled autonomy with observability and governance
- `mcp-contracts`: contract registry + term sheets + memos
- `mcp-market`: market snapshots (simulated or real integration later)
- `mcp-risk`: submits risk jobs + returns results
- `risk-worker`: executes FX VaR / IR DV01 / stress jobs
- `rabbitmq`: queues (jobs/results + DLQs)
- `prometheus + grafana + otel-collector`: monitoring + tracing

**Foundry (Agent Intelligence)**
- Agents hosted in Microsoft Foundry
- Invoked on-demand by AKS orchestrator
- Orchestrates analysis and tool calls via MCP
- Drafts narratives and actions

**Flow**
1. AKS orchestrator detects event (threshold breach, cron schedule, market shock)
2. Orchestrator invokes Foundry agent via API with context
3. Agent calls `mcp-contracts.search_contracts(...)`
4. For each contract: agent calls `mcp-risk.run_fx_var(...)` → returns `job_id`
5. `risk-worker` consumes job from RabbitMQ, computes, publishes result
6. Agent calls `mcp-risk.get_risk_result(job_id)` until complete
7. Agent writes memo: `mcp-contracts.write_risk_memo(...)`
8. Orchestrator monitors results and triggers follow-up actions if needed
9. Dashboard shows exposure, breaches, queue health, latency

---

## 3) Repository Structure (Reference)

```
contract-risk-mcp-foundry/
  README.md
  PROJECT_CREATE.md

  apps/
    agent-orchestrator/      # Event-driven orchestration service
    mcp-market/
    mcp-risk/
    mcp-contracts/
    risk-worker/

  shared/
    contracts/              # pydantic schemas shared across services

  k8s/
    helm/
      platform/             # otel, prom, grafana, ingress, keda
      rabbitmq/             # bitnami rabbitmq
      mcp-tools/            # deploy MCP servers
      risk-workers/         # deploy workers + KEDA ScaledObject

  observability/
    grafana/
      dashboards/
    otel/
    prometheus/

  scripts/
    bootstrap_cluster.sh
    deploy_platform.sh
    deploy_rabbitmq.sh
    deploy_tools.sh
    deploy_workers.sh
    seed_contracts.py
```

---

## 4) Dependencies

### Local development
- Python 3.10+
- Docker
- `kubectl`, `helm`
- Optional: `kind` or `k3d` for local Kubernetes testing

### AKS cluster add-ons (installed via Helm in this repo)
- Ingress controller (nginx)
- Prometheus + Grafana
- OpenTelemetry Collector
- KEDA (for queue-driven autoscaling)
- RabbitMQ (Bitnami chart)

### Python packages (per service)
Core:
- `mcp.server.fastmcp` (FastMCP)
- `pydantic`
- `aio-pika` (RabbitMQ client)
- `opentelemetry-api`, `opentelemetry-sdk`, `opentelemetry-exporter-otlp`

For compute:
- `numpy`, `pandas` (optional), `scipy` (optional)
- lightweight implementations are fine for MVP (no heavy quant libs required)

---

## 5) Standardized Queue Topology (RabbitMQ)

Exchange: `risk.exchange` (direct)

Queues:
- `risk.jobs` (routing key `risk.job`)
- `risk.results` (routing key `risk.result`)
- DLQs: `risk.jobs.dlq`, `risk.results.dlq` (via `risk.dlx`)

Job message shape:
```json
{
  "job_id": "job-123",
  "job_type": "fx_var",
  "contract_id": "ctr-001",
  "params": {"horizon_days": 1, "sims": 20000, "confidence": 0.99},
  "idempotency_key": "ctr-001|fx_var|2026-01-23"
}
```

Result message shape:
```json
{
  "job_id": "job-123",
  "status": "succeeded",
  "contract_id": "ctr-001",
  "result": {
    "var": 125000.12,
    "confidence": 0.99,
    "horizon_days": 1,
    "as_of": "2026-01-23T12:00:00Z"
  }
}
```

---

## 6) Build Phases (Suggested)

### Phase 1 — MVP (demo-ready)
- Simulated contracts + market feed
- `mcp-risk` publishes jobs, `risk-worker` computes basic FX VaR + IR DV01
- `mcp-contracts` stores term sheets + memos (simple DB or in-memory for MVP)
- Grafana dashboards:
  - queue depth
  - job runtime
  - tool latency + errors

### Phase 2 — Production-grade behaviors
- Persistent DB (Postgres/Cosmos) for contracts/results/memos
- Idempotency enforcement + job status store
- Retry policies + dead-letter workflows
- APIM in front of MCP for auth, quotas, logging

### Phase 3 — Risk sophistication
- Stress library (historical shocks)
- Correlated simulations (FX ↔ rates)
- PFE approximation
- Approval workflow (human-in-the-loop)

---

## 7) Local Dev Quickstart (No Kubernetes)

> Optional. You can go straight to AKS. Useful for quick iteration.

### Start RabbitMQ locally
```bash
docker run -d --name rabbitmq \
  -p 5672:5672 -p 15672:15672 \
  rabbitmq:3-management
```

### Run services locally (example)
```bash
cd apps/mcp-risk
pip install -e .
export RABBITMQ_HOST=localhost
export RABBITMQ_USER=guest
export RABBITMQ_PASS=guest
python -m src.main
```

```bash
cd apps/risk-worker
pip install -e .
export RABBITMQ_HOST=localhost
export RABBITMQ_USER=guest
export RABBITMQ_PASS=guest
python -m src.worker
```

---

## 8) AKS Deployment (Helm)

### 8.1 Build and push images
```bash
docker build -t <acr>.azurecr.io/mcp-risk:0.1.0 apps/mcp-risk
docker push <acr>.azurecr.io/mcp-risk:0.1.0

docker build -t <acr>.azurecr.io/risk-worker:0.1.0 apps/risk-worker
docker push <acr>.azurecr.io/risk-worker:0.1.0
```

### 8.2 Install platform add-ons
```bash
helm upgrade --install platform k8s/helm/platform -n platform --create-namespace
```

### 8.3 Install RabbitMQ
```bash
helm upgrade --install rabbitmq k8s/helm/rabbitmq -n rabbitmq --create-namespace
```

### 8.4 Deploy MCP tools
```bash
helm upgrade --install mcp-tools k8s/helm/mcp-tools -n tools --create-namespace
```

### 8.5 Deploy risk workers
```bash
helm upgrade --install risk-workers k8s/helm/risk-workers -n workers --create-namespace
```

---

## 9) Foundry Agent Integration (Invoked by AKS)

AKS orchestrator invokes Foundry agents via API with:
- Event context (threshold breach, scheduled scan, market shock)
- MCP endpoint URLs for tool access
- Task description

Agent tasks:
- `threshold_breach_analysis`: Analyze contracts exceeding risk thresholds
- `market_shock_assessment`: Reassess portfolio after market events
- `daily_portfolio_risk_scan`: Comprehensive risk analysis

Use stable tool names:
- `risk.run_fx_var`
- `risk.get_risk_result`
- `contracts.search_contracts`
- `contracts.write_risk_memo`
- `market.get_fx_spot`

Agent pattern:
1. Receive invocation from AKS with context
2. Retrieve contracts via MCP
3. Decide required risk runs
4. Submit async jobs
5. Poll results
6. Generate memo + actions
7. Persist memo and return to orchestrator

---

## 10) Demo Scenarios

### FX Shock Day
- Seed contracts
- Simulate EURUSD −3%
- Agent re-scores 1-day 99% FX VaR
- Observe:
  - queue spike
  - worker autoscaling
  - breach memos

### Rate Jump
- Simulate +75 bps parallel shift
- Compute DV01 across portfolio
- Generate ranked exposure summary

---

## 11) Completion Criteria

Minimum:
- End-to-end async job flow works
- Foundry agent successfully calls MCP tools
- Grafana shows queue depth, latency, scaling

Strong:
- Shock scenarios trigger autoscaling and risk memos
- Clear separation of reasoning (Foundry) and compute (AKS)
- Dashboards communicate both business risk and platform health

---

## 12) Next Enhancements
- APIM in front of MCP endpoints
- Persistent DB + migrations
- Agent evaluation and regression tests
- Policy-driven hedge approvals
- HITL workflows

